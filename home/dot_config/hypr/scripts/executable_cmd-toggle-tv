#!/usr/bin/env bash

source "${HOME}/.local/share/spinners/spinner.sh"
CACHE_ENABLED=false

TV_MONITOR="HDMI-A-2"
TV_INPUT="HDMI 3"
TV_AUDIO_PROFILE="output:hdmi-stereo-extra3"
DESKTOP_AUDIO_SINK="alsa_output.usb-ACTIONS_Pebble_V3-00.analog-stereo"
STATE_FILE="/tmp/tv-gaming-steam-state"
HA_URL="http://192.168.4.114:8123"
HA_TOKEN_FILE="${HOME}/.config/hypr/scripts/.ha-token"
HA_TV_ENTITY="media_player.cwel_lgtv"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'
ICON_CHECK="✓"
ICON_CROSS="✗"
ICON_ARROW="→"

log_info() {
    echo -e "${CYAN}${ICON_ARROW}${RESET} $1"
}

log_success() {
    echo -e "${GREEN}${ICON_CHECK}${RESET} $1"
}

log_error() {
    echo -e "${RED}${ICON_CROSS}${RESET} $1"
}

log_warn() {
    echo -e "${YELLOW}!${RESET} $1"
}

log_section() {
    echo -e "\n${BOLD}${MAGENTA}━━━ $1 ━━━${RESET}\n"
}


show_status() {
    echo -e "${BOLD}${CYAN}╭─────────────────────────────────╮${RESET}"
    echo -e "${BOLD}${CYAN}│${RESET}  ${BOLD}TV Gaming Mode Status${RESET}      ${BOLD}${CYAN}│${RESET}"
    echo -e "${BOLD}${CYAN}╰─────────────────────────────────╯${RESET}\n"

    if is_tv_on; then
        echo -e "  ${GREEN}${ICON_CHECK}${RESET} TV Power:    ${GREEN}${BOLD}ON${RESET}"
    else
        echo -e "  ${RED}${ICON_CROSS}${RESET} TV Power:    ${DIM}OFF${RESET}"
    fi

    if pgrep -f "gamescope.*steam" > /dev/null; then
        echo -e "  ${GREEN}${ICON_CHECK}${RESET} Gamescope:   ${GREEN}${BOLD}RUNNING${RESET}"
    else
        echo -e "  ${RED}${ICON_CROSS}${RESET} Gamescope:   ${DIM}STOPPED${RESET}"
    fi

    echo ""
}

ACTION=""

case "${1:-}" in
    on)
        ACTION="on"
        ;;
    off)
        ACTION="off"
        ;;
    kill|--kill|-k)
        ACTION="kill"
        ;;
    display|-d)
        ACTION="display"
        ;;
    switch|s|-s)
        ACTION="switch"
        ;;
    "")
        # No arguments - will show status later after functions are defined
        ACTION="status"
        ;;
    *)
        ACTION="error"
        ERROR_MSG="Unknown command: ${BOLD}${1}${RESET}"
        ;;
esac

if command -v hyprctl &>/dev/null && [[ -z "$HYPRLAND_INSTANCE_SIGNATURE" ]]; then
    for pid in $(pgrep -P $(pgrep -u "$USER" Hyprland) 2>/dev/null); do
        [[ -f "/proc/$pid/environ" ]] || continue
        while IFS='=' read -r -d '' k v; do
            [[ "$k" =~ ^(HYPRLAND_INSTANCE_SIGNATURE|WAYLAND_DISPLAY|DISPLAY)$ ]] && export "$k=$v"
        done < "/proc/$pid/environ"
        [[ -n "$HYPRLAND_INSTANCE_SIGNATURE" ]] && break
    done
fi

if [ -z "$XDG_RUNTIME_DIR" ]; then
    runtime_dir="/run/user/$(id -u)"
    if [ -d "$runtime_dir" ]; then
        export XDG_RUNTIME_DIR="$runtime_dir"
    fi
fi

if [ -f "$HA_TOKEN_FILE" ]; then
    HA_TOKEN=$(cat "$HA_TOKEN_FILE")
else
    log_warn "HA token file not found at $HA_TOKEN_FILE"
    HA_TOKEN=""
fi

is_tv_enabled() {
    local monitors_json=$(hyprctl monitors -j 2>/dev/null)
    if [ $? -ne 0 ] || [ -z "$monitors_json" ]; then
        log_error "Failed to get monitor information from hyprctl"
        return 1
    fi
    local is_disabled=$(echo "$monitors_json" | jq -r ".[] | select(.name==\"$TV_MONITOR\") | .disabled" 2>/dev/null)
    [[ "$is_disabled" == "false" ]] || [[ -z "$is_disabled" ]]
}

is_tv_on() {
    if [ -z "$HA_TOKEN" ]; then
        log_warn "No HA token available"
        return 1
    fi

    local state=$(curl -s -H "Authorization: Bearer $HA_TOKEN" \
        "$HA_URL/api/states/$HA_TV_ENTITY" | jq -r '.state' 2>/dev/null)

    [[ "$state" == "on" || "$state" == "playing" || "$state" == "paused" ]]
}

wait_for_tv_power_on() {
    for i in {1..20}; do
        if is_tv_on; then
            return 0
        fi
        sleep 0.5
    done
    return 1
}

wake_tv() {
    if [ -z "$HA_TOKEN" ]; then
        return 1
    fi

    if is_tv_on; then
        return 0
    fi

    curl -s -X POST -H "Authorization: Bearer $HA_TOKEN" \
        -H "Content-Type: application/json" \
        "$HA_URL/api/services/media_player/turn_on" \
        -d "{\"entity_id\":\"$HA_TV_ENTITY\"}" > /dev/null

    wait_for_tv_power_on
    return $?
}

switch_tv_input() {
    if [ -z "$HA_TOKEN" ]; then
        log_warn "No HA token available"
        log_warn "Skipping input switch"
        return 1
    fi

    log_info "Switching TV input to ${BOLD}$TV_INPUT${RESET}"
    curl -s -X POST -H "Authorization: Bearer $HA_TOKEN" \
        -H "Content-Type: application/json" \
        "$HA_URL/api/services/media_player/select_source" \
        -d "{\"entity_id\":\"$HA_TV_ENTITY\",\"source\":\"$TV_INPUT\"}" > /dev/null

    if [ $? -eq 0 ]; then
        log_success "Switched to $TV_INPUT"
    else
        log_error "Failed to switch to $TV_INPUT"
    fi
}

tv_standby() {
    if [ -z "$HA_TOKEN" ]; then
        log_warn "No HA token available"
        log_warn "Skipped sending TV to standby"
        return 1
    fi

    log_info "Putting TV into standby..."
    curl -s -X POST -H "Authorization: Bearer $HA_TOKEN" \
        -H "Content-Type: application/json" \
        "$HA_URL/api/services/media_player/turn_off" \
        -d "{\"entity_id\":\"$HA_TV_ENTITY\"}" > /dev/null

    log_success "TV set to standby"
}

switch_audio_to_tv() {
    log_info "Switching audio output to TV..."
    pactl set-card-profile alsa_card.pci-0000_03_00.1 "$TV_AUDIO_PROFILE" 2>/dev/null
    sleep 1
    local tv_sink_name=$(pactl list sinks short | grep "hdmi-stereo-extra3" | awk '{print $2}')
    if [ -n "$tv_sink_name" ]; then
        pactl set-default-sink "$tv_sink_name" 2>/dev/null
        pactl set-sink-volume "$tv_sink_name" 100% 2>/dev/null
        log_success "Audio switched to TV (HDMI)"
    else
        log_warn "Can't find TV audio sink"
        return 1
    fi
}

switch_audio_to_desktop() {
    log_info "Switching audio to desktop speakers..."
    pactl set-default-sink "$DESKTOP_AUDIO_SINK" 2>/dev/null
    log_success "Audio switched to desktop speakers"
}

is_desktop_steam_running() {
    pgrep -x "steam" > /dev/null && ! pgrep -f "gamescope.*steam" > /dev/null
}

is_gamescope_running() {
    pgrep -f "gamescope.*steam" > /dev/null
}

get_gamescope_tty() {
    local pid=$(pgrep -f "gamescope.*steam" | head -1)
    if [ -z "$pid" ]; then
        echo ""
        return 1
    fi

    # Get the TTY from the process
    local tty=$(ps -o tty= -p "$pid" 2>/dev/null | tr -d ' ')
    echo "$tty"
}

kill_desktop_steam() {
    if ! is_desktop_steam_running; then
        return 0
    fi

    log_info "Shutting down desktop Steam..."
    steam -shutdown &> /dev/null
    sleep 2

    if pgrep -x "steam" > /dev/null; then
        pkill -9 steam
    fi

    touch "$STATE_FILE"
    log_success "Desktop Steam shut down"
}

restart_desktop_steam() {
    if [ ! -f "$STATE_FILE" ]; then
        return 0
    fi

    log_info "Restarting desktop Steam..."
    uwsm app -- steam -silent </dev/null &>/dev/null &
    sleep 2

    if pgrep -x "steam" > /dev/null; then
        log_success "Desktop Steam restarted"
    fi

    rm -f "$STATE_FILE"
}

wait_for_gamescope_start() {
    local max_attempts=30
    local attempt=0
    while [ $attempt -lt $max_attempts ]; do
        if is_gamescope_running; then
            return 0
        fi
        sleep 0.1
        attempt=$((attempt + 1))
    done
    return 1
}

launch_gamescope() {
    if is_gamescope_running; then
        log_info "Gamescope already running on TTY2"
        return 0
    fi

    kill_desktop_steam

    log_info "Switching to TTY2 to start gamescope session..."

    # Switch to TTY2 which will auto-login and launch gamescope via .zprofile
    sudo chvt 2

    return 0
}

kill_gamescope() {
    if ! is_gamescope_running; then
        restart_desktop_steam
        return 0
    fi

    log_info "Terminating Gamescope..."
    pkill -f "gamescope.*steam"
    sleep 2
    if is_gamescope_running; then
        pkill -9 -f "gamescope.*steam"
    fi
    log_success "Gamescope terminated"
    switch_audio_to_desktop
    restart_desktop_steam
}

case "$ACTION" in
    kill)
        log_section "Stopping Gaming Mode"
        kill_gamescope
        echo ""
        exit 0
        ;;

    off)
        log_section "Shutting Down Gaming Mode"
        kill_gamescope
        tv_standby
        echo ""
        exit 0
        ;;

    display)
        log_section "Toggling TV Display"
        if is_tv_on; then
            tv_standby
        else
            if run_with_spinner "dots" "Waiting for TV to power on" "cyan" wake_tv; then
                printf "\r\033[K"  # Clear the line completely
                log_success "TV is powered on"
            else
                printf "\r\033[K"
                log_error "TV failed to power on"
            fi
        fi
        echo ""
        exit 0
        ;;

    on)
        log_section "Starting Gaming Mode"
        if ! is_tv_on; then
            if run_with_spinner "dots" "Waiting for TV to power on" "cyan" wake_tv; then
                printf "\r\033[K"
                log_success "TV is powered on"
            else
                printf "\r\033[K"
                log_error "TV failed to power on"
                exit 1
            fi
        fi

        switch_tv_input
        switch_audio_to_tv

        if run_with_spinner "bouncingBar" "Starting Gamescope" "magenta" launch_gamescope; then
            printf "\r\033[K"
            log_success "Gamescope launched successfully"
        else
            printf "\r\033[K"
            log_error "Gamescope failed to launch"
            exit 1
        fi

        echo -e "\n${GREEN}${BOLD}${ICON_CHECK} Gaming mode ready!${RESET}\n"
        ;;

    switch)
        log_section "Switching Sessions"

        active_vt=$(sudo fgconsole 2>/dev/null)

        if [[ "$active_vt" == "2" ]]; then
            log_info "Switching to TTY1..."
            sudo chvt 1
        else
            # Check if gamescope is running and on which TTY
            if is_gamescope_running; then
                local gs_tty=$(get_gamescope_tty)
                if [[ "$gs_tty" == "tty1" ]]; then
                    log_warn "Gamescope is running on TTY1 (wrong TTY)"
                    log_info "Killing gamescope processes..."
                    pkill -f "gamescope.*steam"
                    sleep 1
                    if is_gamescope_running; then
                        pkill -9 -f "gamescope.*steam"
                    fi
                    log_success "Gamescope processes terminated"
                elif [[ "$gs_tty" == "tty2" ]]; then
                    log_info "Gamescope already running on TTY2"
                fi
            fi

            log_info "Switching to TTY2..."
            sudo chvt 2
        fi
        echo ""
        ;;

    status)
        show_status
        echo -e "${BOLD}Usage:${RESET} ${GREEN}gamer${RESET} ${DIM}{on|off|kill|display|switch}${RESET}\n"
        echo -e "  ${CYAN}on${RESET}       ${ICON_ARROW} Turn TV on ${DIM}>${RESET} Switch input/audio ${DIM}>${RESET} Launch game mode"
        echo -e "  ${CYAN}kill${RESET}     ${ICON_ARROW} Kill gamescope and restore desktop Steam"
        echo -e "  ${CYAN}off${RESET}      ${ICON_ARROW} Kill gamescope ${DIM}+${RESET} send TV to standby"
        echo -e "  ${CYAN}display${RESET}  ${ICON_ARROW} Toggle TV display on/off"
        echo -e "  ${CYAN}switch${RESET}   ${ICON_ARROW} Switch between desktop (TTY1) and gaming mode (TTY2)"
        echo ""
        exit 1
        ;;

    error)
        log_error "$ERROR_MSG"
        echo -e "\n${BOLD}Usage:${RESET} ${GREEN}gamer${RESET} ${DIM}{on|off|kill|display|switch}${RESET}\n"
        echo -e "  ${CYAN}on${RESET}       ${ICON_ARROW} Turn TV on ${DIM}>${RESET} Switch input/audio ${DIM}>${RESET} Launch game mode"
        echo -e "  ${CYAN}kill${RESET}     ${ICON_ARROW} Kill gamescope and restore desktop Steam"
        echo -e "  ${CYAN}off${RESET}      ${ICON_ARROW} Kill gamescope ${DIM}+${RESET} send TV to standby"
        echo -e "  ${CYAN}display${RESET}  ${ICON_ARROW} Toggle TV display on/off"
        echo -e "  ${CYAN}switch${RESET}   ${ICON_ARROW} Switch between desktop (TTY1) and gaming mode (TTY2)"
        echo ""
        exit 1
        ;;
esac
